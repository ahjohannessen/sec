(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{67:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return p})),n.d(t,"default",(function(){return l}));var a=n(2),i=n(6),o=(n(0),n(74)),r={id:"types",title:"Basic Data Types",sidebar_label:"Data Types"},s={unversionedId:"types",id:"types",isDocsHomePage:!1,title:"Basic Data Types",description:"In sec some basic data types surface in many use cases when interacting with EventStoreDB. In order to establish some basics",source:"@site/../sec-docs/target/mdoc/types.md",slug:"/types",permalink:"/sec/docs/types",version:"current",sidebar_label:"Data Types",sidebar:"mainSidebar",previous:{title:"Quick Start",permalink:"/sec/docs/setup"},next:{title:"EsClient API",permalink:"/sec/docs/client_api"}},p=[{value:"StreamId",id:"streamid",children:[]},{value:"StreamPosition",id:"streamposition",children:[]},{value:"LogPosition",id:"logposition",children:[]},{value:"StreamState",id:"streamstate",children:[]},{value:"EventData",id:"eventdata",children:[]},{value:"Event",id:"event",children:[]}],c={rightToc:p};function l(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"In sec some basic data types surface in many use cases when interacting with EventStoreDB. In order to establish some basics\nthese are described in the following - More details about the particulars of these types are in API documentation.  "),Object(o.b)("h3",{id:"streamid"},"StreamId"),Object(o.b)("p",null,"Streams in EventStoreDB have stream identifiers that can be classified as user defined and system defined.\nIn EventStoreDB streams prefixed with ",Object(o.b)("inlineCode",{parentName:"p"},"$")," are reserved for the system, for instance ",Object(o.b)("inlineCode",{parentName:"p"},"$settings"),".\nFurthermore, EventStoreDB also has a concept of metadata streams for streams. Metadata streams for system streams are prefixed\nwith ",Object(o.b)("inlineCode",{parentName:"p"},"$$"),", e.g. the corresponding metadata stream for ",Object(o.b)("inlineCode",{parentName:"p"},"$settings")," is ",Object(o.b)("inlineCode",{parentName:"p"},"$$$settings"),". Metadata streams for user defined\nstreams are prefixed with a ",Object(o.b)("inlineCode",{parentName:"p"},"$"),", e.g. ",Object(o.b)("inlineCode",{parentName:"p"},"user_stream")," has a corresponding metadata stream named ",Object(o.b)("inlineCode",{parentName:"p"},"$user_stream"),"."),Object(o.b)("p",null,"In sec a stream identifier is an ADT called ",Object(o.b)("inlineCode",{parentName:"p"},"StreamId")," with variants ",Object(o.b)("inlineCode",{parentName:"p"},"Id")," and ",Object(o.b)("inlineCode",{parentName:"p"},"MetaId")," - ",Object(o.b)("inlineCode",{parentName:"p"},"Id"),"\nhas two variants, ",Object(o.b)("inlineCode",{parentName:"p"},"Normal")," and ",Object(o.b)("inlineCode",{parentName:"p"},"System"),". The stream identifiers that a user can create are ",Object(o.b)("inlineCode",{parentName:"p"},"Normal")," and ",Object(o.b)("inlineCode",{parentName:"p"},"System"),",\nthis is done with ",Object(o.b)("inlineCode",{parentName:"p"},"StreamId.apply")," that returns an ",Object(o.b)("inlineCode",{parentName:"p"},"Either[InvalidInput, Id]"),". Some examples of ",Object(o.b)("inlineCode",{parentName:"p"},"StreamId")," construction\nare:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'import sec.StreamId\n\nval user   = StreamId("user_stream")    // Right(Normal("user_stream")\nval system = StreamId("$system_stream") // Right(System("system_stream"))\n\n// MetaId for above you get from the metaId method.\n// The render method displays the stream identifier as EventStoreDB sees it.\n\nuser.map(_.metaId.render)   // Right("$$user_stream")\nsystem.map(_.metaId.render) // Right("$$$system_stream")\n\n// Invalid stream identifiers\n\nStreamId("")        // Left(InvalidInput("id cannot be empty"))\nStreamId("$$oops")  // Left(InvalidInput("value must not start with $$, but is $$oops"))\n')),Object(o.b)("p",null,"Moreover, a few common system stream identififiers are located in the ",Object(o.b)("inlineCode",{parentName:"p"},"StreamId")," companion object, for instance:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"import sec.StreamId\n\nStreamId.All.render               // $all\nStreamId.Scavenges.render         // $scavenges\nStreamId.All.metaId.render        // $$$all\nStreamId.Scavenges.metaId.render  // $$$scavenges\n")),Object(o.b)("h3",{id:"streamposition"},"StreamPosition"),Object(o.b)("p",null,"When you store an event in EventStoreDB it is assigned a ",Object(o.b)("strong",{parentName:"p"},"stream position")," in the individual stream it belongs to.\nIn sec a stream position is an ADT called ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition")," with two variants, ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition.Exact")," that contains\na ",Object(o.b)("inlineCode",{parentName:"p"},"Long")," and ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition.End")," that is an object representing the end of a stream."),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition")," that you can create is ",Object(o.b)("inlineCode",{parentName:"p"},"Exact")," and this is done with ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition.apply")," that returns an\n",Object(o.b)("inlineCode",{parentName:"p"},"Either[InvalidInput, Exact]"),". Examples of ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition")," construction:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'import sec.StreamPosition\n\nStreamPosition.Start // Exact(0L)\nStreamPosition(1L)   // Right(Exact(1L))\nStreamPosition.End   // End\nStreamPosition(-1L)  // Left(InvalidInput("value must be >= 0, but is -1"))\n')),Object(o.b)("p",null,"One use case where you need to construct a ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition")," is when you to store a pointer of the last processed\nevent for a particular stream as a ",Object(o.b)("inlineCode",{parentName:"p"},"Long")," in a read model and, e.g. after a restart of your application,\nneed to resume reading from EventStoreDB."),Object(o.b)("h3",{id:"logposition"},"LogPosition"),Object(o.b)("p",null,"All events in EventStoreDB have a logical position in the global transaction log. A logical position consists of a ",Object(o.b)("em",{parentName:"p"},"commit position")," value\nand a ",Object(o.b)("em",{parentName:"p"},"prepare position")," value. In sec this is modelled as an ADT called ",Object(o.b)("inlineCode",{parentName:"p"},"LogPosition")," with two variants, ",Object(o.b)("inlineCode",{parentName:"p"},"LogPosition.Exact"),"\nthat contains two ",Object(o.b)("inlineCode",{parentName:"p"},"Long")," values and ",Object(o.b)("inlineCode",{parentName:"p"},"LogPosition.End")," representing the end of the log."),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"LogPosition")," that you can create from ",Object(o.b)("inlineCode",{parentName:"p"},"Long")," values is ",Object(o.b)("inlineCode",{parentName:"p"},"Exact"),", this is done with ",Object(o.b)("inlineCode",{parentName:"p"},"LogPosition.apply")," that returns an\n",Object(o.b)("inlineCode",{parentName:"p"},"Either[InvalidInput, Exact]"),". Examples of ",Object(o.b)("inlineCode",{parentName:"p"},"LogPosition")," construction:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'import sec.LogPosition\n\nLogPosition.Start    // Exact(0L, 0L)\nLogPosition.End      // End\nLogPosition(1L, 1L)  // Right(Exact(1L, 1L))\nLogPosition(-1L, 0L) // Left(InvalidInput("commit must be >= 0, but is -1"))\nLogPosition(0L, -1L) // Left(InvalidInput("prepare must be >= 0, but is -1"))\nLogPosition(0L, 1L)  // Left(InvalidInput("commit must be >= prepare, but 0 < 1"))\n')),Object(o.b)("p",null,"Cases where you construct a ",Object(o.b)("inlineCode",{parentName:"p"},"LogPosition")," is similar to that of ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition"),", maintaining a pointer of last\nprocessed event. However, here you keep a pointer to the global log, ",Object(o.b)("inlineCode",{parentName:"p"},"StreamId.All"),", instead of an individual\nstream."),Object(o.b)("h3",{id:"streamstate"},"StreamState"),Object(o.b)("p",null,"Some operations, such as appending events to a stream, require that you provide an ",Object(o.b)("em",{parentName:"p"},"expectation")," of what ",Object(o.b)("strong",{parentName:"p"},"state"),"\nthe stream currently is in. If the stream state does not fullfil that expectation then an exception will be raised by EventStoreDB.\nIn sec this expected stream state is represented by the ADT ",Object(o.b)("inlineCode",{parentName:"p"},"StreamState")," that has four variants:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"NoStream")," - The stream does not exist yet. "),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Any")," - No expectation about the current state of the stream."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"StreamExists")," - The stream, or its metadata stream, is present."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"StreamPosition.Exact")," - The stream exists and its last written stream position is expected to be ",Object(o.b)("inlineCode",{parentName:"li"},"Exact"),".")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"StreamState")," expectation can be used to implement optimistic concurrency. When you retrieve a stream from EventStoreDB,\nyou can take note of the current stream position, then when you append to the stream you can determine if the stream has\nbeen modified in the meantime."),Object(o.b)("h3",{id:"eventdata"},"EventData"),Object(o.b)("p",null,"The event data you store in EventStoreDB is composed of an event type, an event id, payload data, metadata and a content type.\nIn sec this is modelled as ",Object(o.b)("inlineCode",{parentName:"p"},"EventData")," with types that are explained below."),Object(o.b)("h4",{id:"eventtype"},"EventType"),Object(o.b)("p",null,"An event type should be supplied for your event data. This is a unique string used to identify the type of event you are\nsaving. One might be tempted to use language runtime types for event types as it might make marshalling more convenient.\nHowever, this is not recommended as it couples storage to your types. Instead, you can use a mapping between event\ntypes stored in EventStoreDB and your concrete runtime types."),Object(o.b)("p",null,"The string that EventStoreDB uses for the event type is modelled in sec as an ADT with two main variants\n",Object(o.b)("inlineCode",{parentName:"p"},"Normal")," and ",Object(o.b)("inlineCode",{parentName:"p"},"System"),". The type that you can create is ",Object(o.b)("inlineCode",{parentName:"p"},"Normal")," and this is done with ",Object(o.b)("inlineCode",{parentName:"p"},"EventType.apply"),"\nthat returns ",Object(o.b)("inlineCode",{parentName:"p"},"Either[InvalidInput, Normal]"),". Input is validated for emptiness and not starting with ",Object(o.b)("inlineCode",{parentName:"p"},"$")," that EventStoreDB\nuses for reserved system defined types such as ",Object(o.b)("inlineCode",{parentName:"p"},"$>")," and ",Object(o.b)("inlineCode",{parentName:"p"},"$metadata"),"."),Object(o.b)("p",null,"Examples of ",Object(o.b)("inlineCode",{parentName:"p"},"EventType")," construction:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'import sec.EventType\n\nEventType("foo.bar.baz") // Right(Normal("foo.bar.baz")\nEventType("")            // Left(InvalidInput("Event type name cannot be empty"))\nEventType("$@")          // Left(InvalidInput("value must not start with $, but is $@"))\n')),Object(o.b)("p",null,"Common system types are located in the companion of ",Object(o.b)("inlineCode",{parentName:"p"},"EventType"),", some examples are:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"import sec.EventType\n\nEventType.LinkTo.render          // $>\nEventType.StreamMetadata.render  // $metadata\nEventType.Settings.render        // $settings\nEventType.StreamReference.render // $@\n")),Object(o.b)("h4",{id:"eventid"},"EventId"),Object(o.b)("p",null,"The format of an event identifier is a ",Object(o.b)("em",{parentName:"p"},Object(o.b)("a",Object(a.a)({parentName:"em"},{href:"https://en.wikipedia.org/wiki/Universally_unique_identifier"}),"uuid"))," and is\nused by EventStoreDB to uniquely identify the event you are trying to append. If two events with the same uuid are appended to\nthe same stream in quick succession EventStoreDB only appends one copy of the event to the stream. More information about this\nis in the EventStoreDB ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://eventstore.com/docs/dotnet-api/optimistic-concurrency-and-idempotence/index.html#idempotence"}),"docs"),"\nabout concurrency and idempotence."),Object(o.b)("h4",{id:"data"},"Data"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"data")," field on ",Object(o.b)("inlineCode",{parentName:"p"},"EventData")," is a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/scodec/scodec-bits"}),"scodec")," ",Object(o.b)("inlineCode",{parentName:"p"},"ByteVector")," encoded representation\nof your event data. If you store your data as JSON you can make use of EventStoreDB functionality for projections.\nHowever, it is also common to store data in a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://developers.google.com/protocol-buffers"}),Object(o.b)("inlineCode",{parentName:"a"},"protocol buffers"))," format."),Object(o.b)("h4",{id:"metadata"},"Metadata"),Object(o.b)("p",null,"It is common to store additional information along side your event data. This can be correlation id, timestamp, audit,\nmarshalling info and so on. EventStoreDB allows you to store a separate byte array containing this information to keep data\nand metadata separate. These extra bytes are stored in a ",Object(o.b)("inlineCode",{parentName:"p"},"ByteVector")," field of ",Object(o.b)("inlineCode",{parentName:"p"},"EventData")," called ",Object(o.b)("inlineCode",{parentName:"p"},"metadata"),"."),Object(o.b)("h4",{id:"contenttype"},"ContentType"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"data")," and ",Object(o.b)("inlineCode",{parentName:"p"},"metadata")," fields on ",Object(o.b)("inlineCode",{parentName:"p"},"EventData")," have a content type, ",Object(o.b)("inlineCode",{parentName:"p"},"ContentType"),", with\nvariants ",Object(o.b)("inlineCode",{parentName:"p"},"Binary")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Json"),". This is used to provide EventStoreDB information about whether the data is stored as json or as\nbinary. As you might have noticed, both ",Object(o.b)("inlineCode",{parentName:"p"},"ByteVector")," fields of ",Object(o.b)("inlineCode",{parentName:"p"},"EventData")," share the same content type, this is because\nEventStoreDB does not support different content types for ",Object(o.b)("inlineCode",{parentName:"p"},"data")," and ",Object(o.b)("inlineCode",{parentName:"p"},"metadata"),"."),Object(o.b)("p",null,"When ",Object(o.b)("inlineCode",{parentName:"p"},"EventType")," is translated to the protocol of EventStoreDB it becomes ",Object(o.b)("inlineCode",{parentName:"p"},"application/octet-stream")," for ",Object(o.b)("inlineCode",{parentName:"p"},"Binary")," and\n",Object(o.b)("inlineCode",{parentName:"p"},"application/json")," for ",Object(o.b)("inlineCode",{parentName:"p"},"Json"),". In the future there might come more content types, e.g. something that corresponds to\n",Object(o.b)("inlineCode",{parentName:"p"},"application/proto")," or ",Object(o.b)("inlineCode",{parentName:"p"},"application/avro"),"."),Object(o.b)("h3",{id:"event"},"Event"),Object(o.b)("p",null,"Event data arriving from EventStoreDB either comes from an individual stream or from the global log. Data retrieved\nfrom the global log contains positions ",Object(o.b)("inlineCode",{parentName:"p"},"LogPosition.Exact")," and ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition.Exact"),", whereas data from an individual\nstream only contains ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition.Exact"),". "),Object(o.b)("p",null,"The difference in position information is encoded in the ",Object(o.b)("em",{parentName:"p"},"ADT")," that models an event, ",Object(o.b)("inlineCode",{parentName:"p"},"Event[P <: Position]")," where ",Object(o.b)("inlineCode",{parentName:"p"},"P"),"\nis either ",Object(o.b)("inlineCode",{parentName:"p"},"Position.All")," containing both position types or ",Object(o.b)("inlineCode",{parentName:"p"},"Position.Stream")," that is an alias for ",Object(o.b)("inlineCode",{parentName:"p"},"StreamPosition.Exact"),". "),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"import sec.{Position, LogPosition, StreamPosition}\n\nval all: Position.All       = Position.All(StreamPosition.Start, LogPosition.Start)\n// all: Position.All = All(\n//   stream = Exact(value = 0L),\n//   log = Exact(commit = 0L, prepare = 0L)\n// )\nval stream: Position.Stream = StreamPosition.Start\n// stream: Position.Stream = Exact(value = 0L)\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Event")," has the variants ",Object(o.b)("inlineCode",{parentName:"p"},"EventRecord")," and ",Object(o.b)("inlineCode",{parentName:"p"},"ResolvedEvent"),"."),Object(o.b)("p",null,"An ",Object(o.b)("inlineCode",{parentName:"p"},"EventRecord")," consists of the following data types:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"streamId: StreamId")," - The stream the event belongs to."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"position: P")," - The ",Object(o.b)("inlineCode",{parentName:"li"},"Position")," information ",Object(o.b)("inlineCode",{parentName:"li"},"P")," about the event."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"eventData: EventData")," - The data of the event."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"created: ZonedDateTime")," - The time the event was created.")),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"ResolvedEvent")," is used when consuming streams that link to other streams. It consists of:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"event: EventRecord")," - The linked event."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"link: EventRecord")," - The linking event record.")),Object(o.b)("p",null,"Later on when using the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/sec/docs/client_api"}),"EsClient API"),", you will learn about reading from streams and instruct EventStoreDB to\nresolve links such that you get events of type ",Object(o.b)("inlineCode",{parentName:"p"},"ResolvedEvent")," back."))}l.isMDXComponent=!0},74:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return u}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),l=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=l(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),b=l(n),d=a,u=b["".concat(r,".").concat(d)]||b[d]||m[d]||o;return n?i.a.createElement(u,s(s({ref:t},c),{},{components:n})):i.a.createElement(u,s({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);